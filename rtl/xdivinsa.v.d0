//Diversifying instruction design 0 Implementing baseline of time varied instruction
module cop_ise #( parameter [6:0] CUSOPCODE = 7'b0001011) // custom 0 is used by default
(
    cop_clk,
    cop_rst,
    cop_valid,
    cop_ready,
    cop_wait,
    cop_wr,
    cop_insn,   
    cop_rs1,   
    cop_rs2,           
    cop_rd    );
input           cop_clk, cop_rst;
input           cop_valid;
output          cop_ready;
output          cop_wait;
output          cop_wr;
input  [31:0]   cop_insn;
input  [31:0]   cop_rs1;
input  [31:0]   cop_rs2;
output [31:0]   cop_rd;

assign cop_wait = 1'b0;
wire isopcode= (cop_insn[6:0] == CUSOPCODE); 
 
//reg [31:0] op1;
//reg [31:0] op2;
reg [6:0]  funct;
reg        op_valid;
always@(posedge cop_clk) begin
    if (cop_rst) begin
//        op1      <= 32'd0;
//        op2      <= 32'd0;
        funct    <= 7'd0;
        op_valid <= 1'b0;
    end    
    else if (cop_valid && isopcode) begin
//        op1      <= cop_rs1;
//        op2      <= cop_rs2;
        funct    <= cop_insn[31:25];   
        op_valid <= 1'b1;
    end
    else op_valid <= 1'b0;
end

wire doAddi = (funct[2:0] == 3'b000)||(funct[2:0] == 3'b100);
wire doMult = (funct[2:0] == 3'b001)||(funct[2:0] == 3'b101);
wire rdrand = (funct[2:0] == 3'b010);
wire rdhigh = (funct[2:0] == 3'b111);

wire [33:0] addi;
wire [63:0] mult;
wire [63:0] arthres;
wire [7:0] randnum; 

//data-path ==========================================
/*digraph datapath {	

}*/
reg         trn_gen;
wire        trn_rdy;
trng_reg #(.W(8), .RI(8), .O(3)) trng_ins (
    .clk(cop_clk),
    .rst(cop_rst),
    .gen(trn_gen),
    .rdy(trn_rdy),
    .rdn(randnum) );
    
reg  [31:0]  artran; //random number for arith. calculation masking
reg  [31:0]  ip11, ip21;
wire [31:0]  op1mask, op2mask;

//wire [31:0] r0 = artran[63:32];
//wire [31:0] r1 = artran[31: 0];

assign op1mask = ip11;
assign op2mask = ip21;
assign addi    = op1mask + op2mask;
assign mult    = op1mask * op2mask;
assign arthres=(doAddi)?{{30{1'b0}},addi}:(doMult)?mult:32'd0;
//====================================================

//control-unit =======================================
/*
digraph G {
    {rank = same; IDLE ARTCAL1 }
    {rank = same; ARTCAL2  ARTFIN }
    {rank = same; ARTCAL3  ARTCAL4  ARTCAL5 }
    {rank = same; ARTCAL3T ARTCAL4T ARTCAL5T ARTFIN_T}

    IDLE      [label="IDLE"];
    ARTCAL1   [label="ARTCAL1 \n  trn_gen "];
    ARTCAL2   [label="ARTCAL2 \n ~trn_gen;\n artran=randnum;\n resreg=0"];
    ARTCAL3   [label="ARTCAL3 \n resreg= resreg + arthres"];
    ARTCAL4   [label="ARTCAL4 \n resreg= resreg - arthres"];
    ARTCAL5   [label="ARTCAL5 \n resreg=(doMult)?resreg-arthres:\n             resreg;"];
    ARTCAL3T  [label="ARTCAL3T"];
    ARTCAL4T  [label="ARTCAL4T"];    
    ARTCAL5T  [label="ARTCAL5T"];
    ARTFIN_T  [label="ARTFIN_T"];
    ARTFIN    [label="ARTFIN  \n resval"];

    IDLE     -> ARTCAL1 [label="op_valid & (doAddi | doMult)"];
    ARTCAL1  -> ARTCAL2 [label="trn_rdy"]; ARTCAL1  -> ARTCAL1;
    ARTCAL2  -> ARTCAL3T;

    ARTCAL3T -> ARTCAL3 [label="ranexp"];  ARTCAL3T -> ARTCAL3T;
    ARTCAL3  -> ARTCAL4T;   
    ARTCAL4T -> ARTCAL4 [label="ranexp"];  ARTCAL4T -> ARTCAL4T;
    ARTCAL4  -> ARTCAL5T;
    ARTCAL5T -> ARTCAL5 [label="ranexp"];  ARTCAL5T -> ARTCAL5T;
    ARTCAL5  -> ARTFIN_T;

    ARTFIN_T -> ARTFIN  [label="ranexp"];  ARTFIN_T -> ARTFIN_T;
    ARTFIN   -> IDLE[];
}
*/
wire       ranexp;  //random timing 

reg [63:0] resreg;
reg        resval;


localparam IDLE    = 4'b0000;
localparam RDNGEN  = 4'b0001;
localparam RDNFIN  = 4'b0010;
localparam ARTCAL1 = 4'b0011;
localparam ARTCAL2 = 4'b0100;
localparam ARTCAL3 = 4'b0110;
localparam ARTCAL3T= 4'b0111;
localparam ARTCAL4 = 4'b1000;
localparam ARTCAL4T= 4'b1001;
localparam ARTCAL5 = 4'b1010;
localparam ARTCAL5T= 4'b1011;
localparam ARTFIN_T= 4'b1100;
localparam ARTFIN  = 4'b1101;

localparam RDHIGH  = 4'b1110;

reg [3:0] ctl_state;
always @(posedge cop_clk)
	if (cop_rst) begin
		ctl_state <= IDLE;
        artran  <= 32'd0;
		resreg  <= 64'd0;
		end
	else
		case (ctl_state)
        IDLE :  if (op_valid & rdrand)
            	    ctl_state    <= RDNGEN;
                else if (op_valid & rdhigh) begin
                    ctl_state    <= RDHIGH;
                    resreg[31:0] <= resreg[63:32];
                    end
                else if (op_valid & (doAddi|doMult))
                    ctl_state    <= ARTCAL1;
                else 
                    ctl_state    <= IDLE;
        RDHIGH :    ctl_state    <= IDLE;          
		RDNGEN : if (trn_rdy) begin
		            ctl_state    <= RDNFIN;
		            resreg       <= {24'd0,randnum};
		         end
        RDNFIN :    ctl_state    <= IDLE;           
        ARTCAL1: if (funct[2]==1'b0)                   // executing random delay time require new random number.
                 begin
                    ctl_state    <= ARTCAL2;
                    resreg       <= 64'd0;
                 end
                 else if (trn_rdy) 
                 begin
                    ctl_state    <= ARTCAL2;
                    artran       <= {24'd0,randnum};
                    resreg       <= 64'd0;
                 end                                  
        ARTCAL2:    ctl_state    <= ARTCAL3T; 
        ARTCAL3T:   ctl_state    <= (ranexp)? ARTCAL3 : ARTCAL3T;          
        ARTCAL3: begin
                    ctl_state    <= ARTFIN;		
                    resreg       <= resreg + arthres;
                 end  
        ARTFIN :    ctl_state    <= IDLE; 
        
        default : begin  // Fault Recovery
            ctl_state <= IDLE;
            artran  <= 32'd0;
	   	    resreg  <= 32'd0;
            end
         endcase
         
always @(ctl_state)
    case (ctl_state)
        IDLE : begin
            resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end
        RDHIGH : begin
            resval    <= 1'b1;
            trn_gen   <= 1'b0;
            end
		RDNGEN : begin
            resval    <= 1'b0;
			trn_gen   <= 1'b1;
            end
        RDNFIN : begin
			resval    <= 1'b1;
			trn_gen   <= 1'b0;
            end
        ARTCAL1: begin
            resval    <= 1'b0;
            trn_gen   <= (funct[2]==1'b0) ? 1'b0 : 1'b1;   // executing random delay time require new random number.
            end
        ARTCAL2: begin
            resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end            
        ARTCAL3T: begin
            resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end
        ARTCAL3: begin
            resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end	  
        ARTFIN : begin
            resval    <= 1'b1;
            trn_gen   <= 1'b0;
            end
        default : begin  // Fault Recovery
		    resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end
    endcase

always @(posedge cop_clk)
	if (cop_rst) begin
	       ip11 <= 32'd0;                      
	       ip21 <= 32'd0;                     
	   end
	else if (ctl_state == ARTCAL3T) 
	   if (ranexp==1'b1) begin
	       ip11 <= cop_rs1;         //op1;                       
	       ip21 <= cop_rs2;         //op2;                        
	   end

// time execution randomising ========================
wire [3:0] timopt = funct[6:3];
wire       timena = timopt[3]; // time execution randomising is enable when timopt[3] (funct[6]) is set.
         
reg [7:0]  timmsk;
always @ (timopt) begin
    case(timopt[2:0])
        3'b000:   timmsk = 8'b0000_0001;
        3'b001:   timmsk = 8'b0000_0011;
        3'b010:   timmsk = 8'b0000_0111;
        3'b011:   timmsk = 8'b0000_1111;
        3'b100:   timmsk = 8'b0001_1111;
        3'b101:   timmsk = 8'b0011_1111;
        3'b110:   timmsk = 8'b0111_1111;
        3'b111:   timmsk = 8'b1111_1111;
    endcase        
end
reg [7:0]  timcnt;  
always @(posedge cop_clk) 
    if (cop_rst)                 timcnt <= 8'h00;
    else if (~timena)            timcnt <= 8'h00;
    else if (timcnt != 8'd0)     timcnt <= timcnt -1'b1;
    else if (ctl_state==ARTCAL2) timcnt <= (funct[2]==1'b0) ? timmsk : timmsk & artran[ 7: 0];
       

assign ranexp = (timcnt == 8'h00);         
//====================================================

assign cop_ready = resval;

assign cop_rd = resreg[31:0];
assign cop_wr = resval;

endmodule
