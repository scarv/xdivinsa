//Diversifying instruction design 0 Implementing baseline of time varied instruction
module cop_ise #( 
parameter [6:0] CUSOPCODE = 7'b0001011,   // custom 0 is used by default
parameter 		TB =  0 				  // 1: Use for testbench to verify the control interface
) 
(
    cop_clk,
    cop_rst,
    cop_valid,
    cop_ready,
    cop_wait,
    cop_wr,
    cop_insn,   
    cop_rs1,   
    cop_rs2,           
    cop_rd    );
input           cop_clk, cop_rst;
input           cop_valid;
output          cop_ready;
output          cop_wait;
output          cop_wr;
input  [31:0]   cop_insn;
input  [31:0]   cop_rs1;
input  [31:0]   cop_rs2;
output [31:0]   cop_rd;

wire isopcode= (cop_insn[6:0] == CUSOPCODE); 
 
wire       op_valid = cop_valid && isopcode;
wire [6:0] funct    = cop_insn[31:25];

/*
reg [6:0]  funct_lat;
always@(posedge cop_clk) begin
    if (cop_rst) begin
        funct_lat    <= 7'd0;
    end    
    else if (op_valid) begin
        funct_lat    <= funct;   
    end
end
*/
//wire doAddi = (funct[2:0] == 3'b000)||(funct[2:0] == 3'b100);
//wire doMult = (funct[2:0] == 3'b001)||(funct[2:0] == 3'b101);
wire doAddi = (funct[2:0] == 3'b100);
wire doMult = (funct[2:0] == 3'b101);
wire doXori = (funct[2:0] == 3'b110);
wire rdrand = (funct[2:0] == 3'b010);
wire rdhigh = (funct[2:0] == 3'b111);

wire [31:0] xori;
wire [32:0] addi;
wire [63:0] mult;
wire [63:0] arthres;


//data-path ==========================================
/*digraph datapath {	

}*/

reg         trn_gen;
wire        trn_rdy;
wire [7:0]  randnum;
generate
    if (TB==0) begin: es_trng_gen
		trng_reg #(.W(8), .RI(8), .O(3)) trng_ins (
    		.clk(cop_clk),
    		.rst(cop_rst),
		    .gen(trn_gen),
		    .rdy(trn_rdy),
		    .rdn(randnum) );
		    
	end else begin: es_trng_tb
		reg [7:0] randnum_sim;
		reg       trn_rdy_sim;
		reg       trn_gen_sim;
        reg [3:0] dl;
		
		always @(posedge cop_clk) 
            if  (cop_rst)       trn_gen_sim <= 1'b0;
            else if (trn_gen)  begin
                trn_gen_sim <= 1'b1;
                @(posedge cop_clk)
                @(posedge cop_clk)
                @(posedge cop_clk)
                @(posedge cop_clk)
                @(posedge cop_clk)                
                trn_gen_sim <= 1'b0;
                end
             
        always @(posedge cop_clk)
             if  (cop_rst)  begin
                     trn_rdy_sim    <= 1'b0;
                     randnum_sim    <= 8'd0;
                     end
                 else if ((trn_gen==1'b1)&&(trn_gen_sim==1'b0)) begin
                     trn_rdy_sim    <= 1'b1;
                     randnum_sim    <= $random;
                     end
                 else begin
                     trn_rdy_sim    <= 1'b0;
                     end
                                    
		assign trn_rdy = trn_rdy_sim;
 		assign randnum = randnum_sim;
    end  
endgenerate
    
//reg  [31:0]  artran; //random number for arith. calculation masking
reg  [31:0]  ip11, ip21;
wire [31:0]  op1mask, op2mask;


assign op1mask = ip11;
assign op2mask = ip21;
assign xori    = op1mask ^ op2mask;
assign addi    = op1mask + op2mask;
assign mult    = op1mask * op2mask;
assign arthres = (doXori)? {{32{1'b0}},xori} : (doAddi)?{{31{1'b0}},addi}:(doMult)?mult:64'd0;
//====================================================

//control-unit =======================================
/*
digraph G {
    {rank = same; IDLE ARTCAL1 }
    {rank = same; ARTCAL2  ARTFIN }
    {rank = same; ARTCAL3  ARTCAL4  ARTCAL5 }
    {rank = same; ARTCAL3T ARTCAL4T ARTCAL5T ARTFIN_T}

    IDLE      [label="IDLE"];
    ARTCAL1   [label="ARTCAL1 \n  trn_gen "];
    ARTCAL2   [label="ARTCAL2 \n ~trn_gen;\n artran=randnum;\n resreg=0"];
    ARTCAL3   [label="ARTCAL3 \n resreg= resreg + arthres"];
    ARTCAL4   [label="ARTCAL4 \n resreg= resreg - arthres"];
    ARTCAL5   [label="ARTCAL5 \n resreg=(doMult)?resreg-arthres:\n             resreg;"];
    ARTCAL3T  [label="ARTCAL3T"];
    ARTCAL4T  [label="ARTCAL4T"];    
    ARTCAL5T  [label="ARTCAL5T"];
    ARTFIN_T  [label="ARTFIN_T"];
    ARTFIN    [label="ARTFIN  \n resval"];

    IDLE     -> ARTCAL1 [label="op_valid & (doAddi | doMult)"];
    ARTCAL1  -> ARTCAL2 [label="trn_rdy"]; ARTCAL1  -> ARTCAL1;
    ARTCAL2  -> ARTCAL3T;

    ARTCAL3T -> ARTCAL3 [label="ranexp"];  ARTCAL3T -> ARTCAL3T;
    ARTCAL3  -> ARTCAL4T;   
    ARTCAL4T -> ARTCAL4 [label="ranexp"];  ARTCAL4T -> ARTCAL4T;
    ARTCAL4  -> ARTCAL5T;
    ARTCAL5T -> ARTCAL5 [label="ranexp"];  ARTCAL5T -> ARTCAL5T;
    ARTCAL5  -> ARTFIN_T;

    ARTFIN_T -> ARTFIN  [label="ranexp"];  ARTFIN_T -> ARTFIN_T;
    ARTFIN   -> IDLE[];
}
*/
wire       ranexp;  //random timing 

reg [63:0] resreg;
reg        resval;


localparam IDLE    = 4'b0000;
localparam RDNGEN  = 4'b0001;
localparam RDNFIN  = 4'b0010;
localparam ARTCAL1 = 4'b0011;
localparam ARTCAL2 = 4'b0100;
localparam ARTCAL3 = 4'b0110;
localparam ARTCAL3T= 4'b0111;
localparam ARTCAL4 = 4'b1000;
localparam ARTCAL4T= 4'b1001;
localparam ARTCAL5 = 4'b1010;
localparam ARTCAL5T= 4'b1011;
localparam ARTFIN_T= 4'b1100;
localparam ARTFIN  = 4'b1101;

localparam RDHIGH  = 4'b1110;

reg [3:0] ctl_state;
always @(posedge cop_clk)
	if (cop_rst) begin
		ctl_state <= IDLE;
//        artran  <= 32'd0;
		resreg  <= 64'd0;
		end
	else
		case (ctl_state)
        IDLE :  if (op_valid & rdrand)
            	    ctl_state    <= RDNGEN;
                else if (op_valid & rdhigh) begin
                    ctl_state    <= RDHIGH;
                    resreg[31:0] <= resreg[63:32];
                    //resreg[31:0] <= 32'hAAAAAAAA;
                    end
                else if (op_valid & (doXori|doAddi|doMult)) begin
					ctl_state    <= ARTCAL1;                    
//					if (trn_rdy) artran  <= {24'd0,randnum};
					end
                else 
                    ctl_state    <= IDLE;
        RDHIGH :    ctl_state    <= IDLE;          
		RDNGEN : if (trn_rdy) begin
		            ctl_state    <= RDNFIN;
		            resreg[31:0] <= {24'd0,randnum};
		         end
        RDNFIN :    ctl_state    <= IDLE;           
        ARTCAL1: //if (funct_lat[2]==1'b1)                   // executing random delay time require new random number.
                 if (funct[6]==1'b1)
                 begin
                    if (trn_rdy) begin
//					    artran       <= {24'd0,randnum};
                        ctl_state    <= ARTCAL3T;                    
                        resreg       <= 64'd0;
                        end
                    end 
                 else begin
                    ctl_state    <= ARTCAL3T;
                    resreg       <= 64'd0;
                 end
        ARTCAL3T:   ctl_state    <= (ranexp)? ARTCAL3 : ARTCAL3T;          
        ARTCAL3: begin
                    ctl_state    <= ARTFIN;		
                    resreg       <= arthres;
                 end  
        ARTFIN :    ctl_state    <= IDLE; 
        
        default : begin  // Fault Recovery
            ctl_state <= IDLE;
//            artran  <= 32'd0;
	   	    resreg  <= 64'd0;
            end
         endcase
         
always @(*)
    case (ctl_state)
        IDLE : begin
            resval    <= 1'b0;
            //trn_gen   <= (op_valid & (rdrand|((doAddi|doMult)&funct[2])));
            trn_gen   <= (op_valid & (rdrand|((doXori|doAddi|doMult)&funct[6])));
            end
        RDHIGH : begin
            resval    <= 1'b1;
            trn_gen   <= 1'b0;
            end
		RDNGEN : begin
            resval    <= 1'b0;
			trn_gen   <= 1'b1;
            end
        RDNFIN : begin
			resval    <= 1'b1;
			trn_gen   <= 1'b0;
            end
        ARTCAL1: begin
            resval    <= 1'b0;
            // trn_gen   <= funct_lat[2];   // executing random delay time require new random number.
            trn_gen   <= 1'b1; 
            end         
        ARTCAL3T: begin
            resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end
        ARTCAL3: begin
            resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end	  
        ARTFIN : begin
            resval    <= 1'b1;
            trn_gen   <= 1'b0;
            end
        default : begin  // Fault Recovery
		    resval    <= 1'b0;
            trn_gen   <= 1'b0;
            end
    endcase

always @(posedge cop_clk)
	if (cop_rst) begin
	       ip11 <= 32'd0;                      
	       ip21 <= 32'd0;                     
	   end
	else if (ctl_state == ARTCAL3T) 
	   if (ranexp==1'b1) begin
	       ip11 <= cop_rs1;         //op1;                       
	       ip21 <= cop_rs2;         //op2;                        
	   end

// time execution randomising ========================
//wire [3:0] timopt = funct_lat[6:3];
wire [3:0] timopt = funct[6:3];
wire       timena = timopt[3]; // time execution randomising is enable when timopt[3] (funct[6]) is set.
         
reg [7:0]  timmsk;
always @ (timopt) begin
    case(timopt[2:0])
        3'b000:   timmsk = 8'b0000_0001;
        3'b001:   timmsk = 8'b0000_0011;
        3'b010:   timmsk = 8'b0000_0111;
        3'b011:   timmsk = 8'b0000_1111;
        3'b100:   timmsk = 8'b0001_1111;
        3'b101:   timmsk = 8'b0011_1111;
        3'b110:   timmsk = 8'b0111_1111;
        3'b111:   timmsk = 8'b1111_1111;
    endcase        
end
reg [7:0]  timcnt;  
always @(posedge cop_clk) 
    if (cop_rst)                 timcnt <= 8'h00;
    else if (~timena)            timcnt <= 8'h00;
    else if (timcnt != 8'd0)     timcnt <= timcnt -1'b1;
    //else if (ctl_state==ARTCAL1) timcnt <= (funct_lat[2]==1'b0) ? timmsk : (timmsk & randnum[ 7: 0]);
    else if (ctl_state==ARTCAL1) timcnt <= (timmsk & randnum[ 7: 0]);
       

assign ranexp = (timcnt == 8'h00);         
//====================================================

reg cop_wait;
always@(posedge cop_clk) begin
    if (cop_rst)                        cop_wait <= 1'b0;
    else if (ctl_state == ARTCAL3T) 	cop_wait <= 1'b1;
    else                                cop_wait <= 1'b0;
end

assign cop_ready = resval;

assign cop_rd = resreg[31:0];
assign cop_wr = resval;

endmodule
