//Diversifying instruction design 0.1 
//Implementing time varied instructions.
//The instructions performs some dummy masking calcluations while doing random delay 

module cop_ise #( 
parameter [6:0] CUSOPCODE = 7'b0001011,   // custom 0 is used by default
parameter 	TB        = 0		  // 1: Use for testbench to verify the control interface
) 
(
    cop_clk,
    cop_rst,
    cop_valid,
    cop_ready,
    cop_wait,
    cop_wr,
    cop_insn,   
    cop_rs1,   
    cop_rs2,           
    cop_rd    );
input           cop_clk, cop_rst;
input           cop_valid;
output          cop_ready;
output          cop_wait;
output          cop_wr;
input  [31:0]   cop_insn;
input  [31:0]   cop_rs1;
input  [31:0]   cop_rs2;
output [31:0]   cop_rd;

wire isopcode= (cop_insn[6:0] == CUSOPCODE); 
 
wire       op_valid = cop_valid && isopcode;
wire [6:0] funct    = cop_insn[31:25];

wire doAddi = (funct[2:0] == 3'b100);
wire doXori = (funct[2:0] == 3'b110);
wire rdrand = (funct[2:0] == 3'b010);

//data-path ==========================================
/*digraph datapath {	

}*/

wire        trn_gen = 1'b1;
wire        trn_rdy;
wire [7:0]  randnum;
generate
    if (TB==0) begin: es_trng_gen
		trng_reg #(.W(8), .RI(8), .O(3)) trng_ins (
    		.clk(cop_clk),
    		.rst(cop_rst),
		    .gen(trn_gen),
		    .rdy(trn_rdy),
		    .rdn(randnum) );
		    
	end else begin: es_trng_tb
		reg [7:0] randnum_sim;
		reg       trn_rdy_sim;
		reg       trn_gen_sim;
        reg [3:0] dl;
		
		always @(posedge cop_clk) 
            if  (cop_rst)       trn_gen_sim <= 1'b0;
            else if (trn_gen)  begin
                trn_gen_sim <= 1'b1;
                @(posedge cop_clk)
                @(posedge cop_clk)
                @(posedge cop_clk)
                @(posedge cop_clk)
                @(posedge cop_clk)                
                trn_gen_sim <= 1'b0;
                end
             
        always @(posedge cop_clk)
             if  (cop_rst)  begin
                     trn_rdy_sim    <= 1'b0;
                     randnum_sim    <= 8'd0;
                     end
                 else if ((trn_gen==1'b1)&&(trn_gen_sim==1'b0)) begin
                     trn_rdy_sim    <= 1'b1;
                     randnum_sim    <= $random;
                     end
                 else begin
                     trn_rdy_sim    <= 1'b0;
                     end
                                    
		assign trn_rdy = trn_rdy_sim;
 		assign randnum = randnum_sim;
    end  
endgenerate

// PRNG for dummy operations ================================
reg  [31:0]   prng_seed;
always @(posedge cop_clk) begin
    if(cop_rst)           prng_seed <= 32'h6789ABCD;
    else if(trn_rdy)      prng_seed <= {prng_seed[23:0], randnum};
end

reg  [1:0]   trn_cnt;
always @(posedge cop_clk) begin
    if(cop_rst)           trn_cnt <= 2'b00;
    else if(trn_rdy)      trn_cnt <= trn_cnt +1'b1;
end

wire          prng_reseed;
reg  [31:0]   prng;
wire        n_prng_lsb = prng[31] ~^ prng[21] ~^ prng[ 1] ~^ prng[ 0];
wire [31:0] n_prng     = {prng[31-1:0], n_prng_lsb};
// Process for updating the LFSR.
always @(posedge cop_clk) begin
    if(cop_rst)           prng <= 32'h6789ABCD;
    else if(prng_reseed)  prng <= prng_seed;
    else                  prng <= n_prng;
end
assign prng_reseed = (trn_rdy&&(trn_cnt == 2'b11));
//====================================================================

wire [31:0] op1mask, op2mask;

wire docal;

assign      op1mask = (docal)? cop_rs1: prng;
assign      op2mask = cop_rs2;
wire [31:0] xori    = op1mask ^ op2mask;
wire [31:0] addi    = op1mask + op2mask;
wire [31:0] calc    = (doXori)? xori : (doAddi)? addi:32'd0;
//====================================================
reg [31:0] calreg;
always @(posedge cop_clk) begin
    if(cop_rst)               calreg <= 32'd0;
    else if(doXori | doAddi)  calreg <= calc;
end

reg latch_ena;
always @(posedge cop_clk) begin
    if(cop_rst)     		 latch_ena <=1'b0;
    else if(doXori | doAddi) latch_ena <= docal;
end

//control-unit =======================================
/*

*/
wire       ranexp;  //random timing 
reg [31:0] resreg;
reg [ 3:0] ctl_state;

localparam IDLE    = 4'b0000;
localparam RDNGEN  = 4'b0001;
localparam RDNFIN  = 4'b0010;
localparam ARTCAL1 = 4'b0011;
localparam ARTCAL2 = 4'b0100;
localparam ARTCAL3 = 4'b0110;
localparam ARTCAL3T= 4'b0111;
localparam ARTCAL4 = 4'b1000;
localparam ARTCAL4T= 4'b1001;
localparam ARTCAL5 = 4'b1010;
localparam ARTCAL5T= 4'b1011;
localparam ARTFIN_T= 4'b1100;
localparam ARTFIN  = 4'b1101;

localparam RDHIGH  = 4'b1110;


always @(posedge cop_clk)
	if (cop_rst)    ctl_state <= IDLE;
	else
		case (ctl_state)
        IDLE :  	ctl_state <= (op_valid & rdrand) ?          RDNGEN:
								 (op_valid & (doXori|doAddi)) ? ARTCAL1: 
																IDLE;  
		RDNGEN : 	ctl_state <= RDNFIN;

        ARTCAL1:    ctl_state <= ARTCAL3T;
        ARTCAL3T:	ctl_state <= (ranexp)? ARTCAL3 : ARTCAL3T;    
        ARTCAL3:    ctl_state <= ARTFIN;		

        RDNFIN :    ctl_state <= IDLE;           
        ARTFIN :    ctl_state <= IDLE;
         
        default :   ctl_state <= IDLE;
        endcase
         
// time execution randomising ========================
wire [3:0] timopt = funct[6:3];
wire       timena = timopt[3]; // time execution randomising is enable when timopt[3] (funct[6]) is set.
         
reg [7:0]  timmsk;
always @ (timopt) begin
    case(timopt[2:0])
        3'b000:   timmsk = 8'b0000_0001;
        3'b001:   timmsk = 8'b0000_0011;
        3'b010:   timmsk = 8'b0000_0111;
        3'b011:   timmsk = 8'b0000_1111;
        3'b100:   timmsk = 8'b0001_1111;
        3'b101:   timmsk = 8'b0011_1111;
        3'b110:   timmsk = 8'b0111_1111;
        3'b111:   timmsk = 8'b1111_1111;
    endcase        
end
reg [7:0]  timcnt,timreg;  
always @(posedge cop_clk) 
    if (cop_rst)                 timcnt <= 8'h00;
    else if (~timena)            timcnt <= 8'h00;
    else if (timcnt != 8'd0)     timcnt <= timcnt -1'b1;
    else if (ctl_state==ARTCAL1) timcnt <= (timmsk & randnum[ 7: 0]);

always @(posedge cop_clk) 
    if (cop_rst)                 timreg <= 8'h00;
    else if (~timena)            timreg <= 8'h00;
    else if (ctl_state==ARTCAL1) timreg <= (timmsk & randnum[ 7: 0]);

assign docal  = (timcnt == {1'b0,timreg[7:1]});   // calculate at the middle of the random delay.     
assign ranexp = (timcnt == 8'h00);         
//====================================================

reg cop_wait;
always@(posedge cop_clk) begin
    if (cop_rst)                        cop_wait <= 1'b0;
    else if (ctl_state == ARTCAL3T) 	cop_wait <= 1'b1;
    else                                cop_wait <= 1'b0;
end

always@(posedge cop_clk) begin
    if (cop_rst)                        resreg <= 32'd0;
    else if (ctl_state == RDNGEN) 		resreg <= {24'd0,randnum};
    else if (latch_ena)                 resreg <= calreg;
end

assign cop_ready = (ctl_state == RDNFIN)||(ctl_state == ARTFIN)	;

assign cop_rd = resreg[31:0];
assign cop_wr = cop_ready;

endmodule
