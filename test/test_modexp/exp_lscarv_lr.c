#include "common.h"
#include <scarv/mp/mpn.h>
#include <scarv/mp/mpz.h>
#include <scarv/mp/mrz.h>
#define  W 3
#define PW (1<<(W-1))  //(2^(W-1))
int NL= 32;

mrz_ctx_t ctx;

// Left to Right Window format of the key.
void LtRWinFrm(uint8_t *d, const limb_t* k, int l_k){
	int i,j;
	limb_t t;
	uint8_t wi;

	for( int i = 0; i < l_k; i++ ) {
		t=k[i];
		for( int j = 0; j< BITSOF( limb_t ); j++ ) {
			d[ i*BITSOF( limb_t ) +j] = t & 1;
			t >>=1;
		}
	}
	
	i= l_k*BITSOF( limb_t )-1;
	while (i>=0){
		if (d[i]){
			//printf("i=%d, ", i);
			j=(i>=W)?W:i+1;
			while (d[i-j+1]==0){j--;}
			i = i-j+1;
			wi=0;
			while (j>0){ 
				wi<<=1;
				if (d[i+j-1]) {wi+=1;}  
				d[i+j-1] = 0;
				j--;				
			}		
			d[i]= wi;			 
		}
		i --;		
	}
}

void LtRPreCom(const mrz_ctx_t* ctx, mrz_t * b, const mrz_t x) {
    mrz_t x2;
    
    memcpy( b[0], ctx->rho_1, SIZEOF( mrz_t ) );
    //Precomputation
	mrz_mul( ctx, b[0], b[0], x );	// b[0]=x
	mrz_mul( ctx, x2, b[0], x );	// x2 = x*x 

	for (int i = 1; i < PW; i++) {
		mrz_mul( ctx, b[i], b[i-1], x2 );   //b[i]=b[i-1]*x^2		
	}
}

void exp_lr( const mrz_ctx_t* ctx, mrz_t r, const mrz_t x, const mrz_t* b, const uint8_t* d, int l_k ) {
	mrz_t t;
	int i;

//calculation loop
	memcpy( t, ctx->rho_1, SIZEOF( mrz_t ) );
	
    i = l_k*BITSOF( limb_t ) - 1;
	while (i>=0){
		mrz_mul( ctx, t, t, t );
		if (d[i] != 0){
			mrz_mul( ctx, t, t, b[(d[i]>>1)]);			
		}	
		i --;	
	}
	memcpy( r,          t, SIZEOF( mrz_t ) );
}

int riscv_main() {

	gpio_init();
    uart_init();
	uint32_t t_beg,t_end;

    putstr("\nExp left-to-right sliding window (w=3) \n");	

	uint8_t d[NL * BITSOF( limb_t )];	

	mrz_t N; int l_N;
    mrz_t x; int l_x;
    mrz_t k; int l_k;
    mrz_t r; int l_r;
		
    mrz_t b[PW];

    /* python code to generate 1024 bit key of RSA
    from Crypto.PublicKey import RSA 
    new_key = RSA.generate(1024, e=65537)
    bn= new_key.n.to_bytes(128,'little')
    Narr=",".join("0x{:02x}".format(b) for b in bn)
    bd= new_key.d.to_bytes(128,'little')
    karr=",".join("0x{:02x}".format(b) for b in bd)
	*/
    uint8_t  Narr[128]= {0x49,0xb3,0x20,0x7c,0x85,0x71,0x67,0x79,0x8e,0x68,0x78,0x88,0x2a,0x44,0xbb,0x0e, \
                         0x83,0x85,0x03,0x46,0x3e,0xc6,0x8b,0x7f,0xff,0xe5,0xfe,0xd7,0x25,0x81,0x0b,0x5f, \
                         0x21,0x6b,0x35,0xc2,0x85,0x9a,0x58,0xda,0xf3,0x9f,0x8a,0x27,0xb3,0x75,0x59,0x09, \
                         0x44,0x42,0xb3,0x5e,0xc2,0x4b,0xa0,0xb0,0x88,0xae,0x2a,0x54,0x92,0x74,0xf0,0x9a, \
                         0xa5,0xef,0x5e,0xc0,0xa3,0xd4,0xf4,0xed,0x10,0x88,0xe9,0xd8,0xb9,0xd8,0x22,0x6e, \
                         0xa8,0x6f,0x42,0x3e,0xac,0x28,0xa9,0x3d,0xc2,0xc3,0x17,0x13,0xfe,0x8e,0xd4,0x65, \
                         0x02,0x40,0xa8,0x73,0x02,0x9d,0x26,0xd8,0x8b,0xdf,0x01,0x93,0x06,0x11,0x40,0x14, \
                         0x2d,0x77,0xe2,0x22,0x35,0x47,0xd6,0xe2,0xeb,0x48,0x8b,0x21,0x90,0x81,0x8c,0xd2};
    uint8_t  karr[128]= {0xb9,0x32,0xda,0x57,0x0a,0x15,0xb0,0x9e,0xee,0xf2,0x0e,0x56,0xed,0xbd,0x70,0x68, \
                         0x02,0x77,0x54,0xe7,0x43,0x23,0x1a,0xe8,0x92,0x85,0xd2,0xc8,0xd9,0xff,0xcc,0xbd, \
                         0xdd,0x33,0x88,0x4a,0xd2,0x91,0x1f,0x6e,0x1f,0x27,0x7c,0xc8,0xef,0xcb,0xd8,0x81, \
                         0x84,0x9d,0xd0,0x22,0x92,0xef,0x99,0x2a,0x91,0x93,0x5c,0x2d,0xe2,0xb8,0xa7,0xfc, \
                         0x66,0x8e,0xaf,0xe5,0x19,0x8a,0xc1,0x33,0x96,0x8b,0x98,0x21,0xfe,0x09,0x30,0xfb, \
                         0x06,0x32,0x91,0x82,0xd5,0x2d,0xd5,0x9c,0xf0,0x2d,0x27,0xba,0x97,0xf4,0x02,0xf2, \
                         0xbd,0xe1,0x2d,0xfd,0x75,0x4e,0x4a,0xc6,0x6d,0xa0,0x00,0x4b,0xa2,0x68,0x30,0xed, \
                         0x68,0xdb,0xf5,0xa6,0x12,0x9b,0x98,0xbd,0xd4,0x61,0x58,0x4d,0x1b,0x4b,0xba,0x1c};

    uint8_t  xarr[128]= {0xe0,0xfe,0x18,0x0b,0xee,0xdd,0x99,0x48,0x27,0xe0,0x9f,0x01,0x6e,0x63,0xb6,0xee, \
                         0xc3,0xf8,0xc4,0xcf,0x59,0x10,0x2c,0xd2,0xd9,0xc2,0xaf,0x7d,0xde,0xe7,0x69,0x37, \
                         0x80,0x85,0x9a,0x42,0xde,0xd2,0x56,0xdd,0xe0,0x1f,0x8c,0x3a,0x5a,0x07,0xd7,0xfe, \
                         0x3a,0xf5,0xd6,0x85,0xd5,0x81,0x66,0xdc,0xc0,0xf8,0xfc,0x9d,0x9b,0x19,0xc3,0x92, \
                         0x19,0x41,0xdd,0x71,0xbf,0x27,0x9d,0x94,0xd5,0x40,0xba,0xc6,0x7e,0xea,0x81,0xbb, \
                         0xaa,0xe2,0x51,0xf8,0xf9,0xaa,0x54,0xfa,0x7b,0x02,0xf2,0xcf,0xfb,0xce,0x75,0x2a, \
                         0xd6,0xb2,0x47,0xe6,0x77,0xb9,0x81,0x8e,0x0f,0x54,0x65,0xec,0x51,0x2b,0xb9,0xf5, \
                         0x22,0xfc,0x9b,0x5f,0x9b,0x57,0x60,0xdd,0x00,0x89,0x9a,0xf4,0x81,0x0c,0x80,0x66};
	l_N = l_r = l_x= l_k = NL;

	memcpy( N, Narr, NL * SIZEOF( limb_t ) );
	memcpy( x, xarr, NL * SIZEOF( limb_t ) );
	memcpy( k, karr, NL * SIZEOF( limb_t ) );

	mrz_precomp( &ctx, N, l_N );
	LtRWinFrm(d, k, l_k);

    for(int i=0; i<10; i++){
        mrz_mul( &ctx, r, x, ctx.rho_2 );
     	LtRPreCom(&ctx,b,r);    
        set_trigger();
        t_beg 	= rdcycle();
        exp_lr( &ctx, r, r, b, d, l_k );
        t_end 	= rdcycle();
        clear_trigger();
        mrz_mul( &ctx, r, r, ctx.rho_0 );

#ifdef TEST_DUMP
	test_dump( "N", N, l_N );  
    test_dump( "x", x, l_x );  
    test_dump( "k", k, l_k );  
    test_dump( "r", r, l_r ); 	
    putstr("(0x"); puthex8(1); putstr(", 0x"); puthex(t_end-t_beg); putstr(")  \n");
#else
        putstr("0x"); puthex(t_end-t_beg); putstr("\n");
#endif
    }
	return 0;
}

void riscv_irq_delegated_handler() {

}
